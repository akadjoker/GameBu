 
 

def printer(tag, val1, val2)
{
    // Se a stack estiver desalinhada:
    // tag pode virar nil, val1 vira tag, etc.
    print("Tag: " + tag);
    print("Soma: " + (val1 + val2)); 
    
    
}

process test_spawn()
{
    // Passamos 3 argumentos
    fiber printer("CHECK", 10, 20);
    frame;
}

test_spawn();


print("--- TESTE: Logic & Yield ---");

struct State { x, y };

def worker(st)
{
    var steps = 0;
    while (steps < 3) 
    {  
        st.x = st.x + 1;
        print("Step " + steps + ": x=" + st.x);
        yield;
        steps++;
    }
    print("Worker Done");
}

process enemy()
{
    var s = State(0, 0);
    fiber worker(s);
    
    // Deixamos o fiber correr 4 frames
    frame; frame; frame; frame;
    
  
}

enemy();


print("--- TESTE: Recursion inside Fiber ---");

var finalResult = 0;

def factorial(n)
{
    if (n <= 1) return 1;
    
    yield; // Pausa para garantir que a stack sobrevive ao yield
    

    return n * factorial(n - 1);
}

def runner()
{
    finalResult = factorial(5);
}

process math_test()
{
    fiber runner();
    
    // Precisamos de vários frames por causa dos yields recursivos
    var i = 0;
    while (i < 10)
    {
        frame;
        i++;
    }
    
    print("Fatorial de 5: " + finalResult);
     
}

math_test();




// ==========================================
// CASO 1: Execução Básica de Fiber
// ==========================================
var fiberRan = false;

def simpleFiber() {
    print("   -> Fiber iniciou");
    fiberRan = true;

}

process fiberTest1() {
    fiber simpleFiber();
    var i = 0;
    while (i < 1000) 
    {
        frame; // Mantém o pai vivo enquanto o filho corre
        i++;
    }
  
}

fiberTest1();

 

var timerDone = false;

def sleeper() 
{
    yield(50); // Espera ~3 frames (assumindo 16ms por frame)
    timerDone = true;
}

process timeTest() {
    fiber sleeper();
    
    frame; // ~16ms
 
    
    frame; // ~32ms
    
    
    frame; // ~48ms (quase lá)
    
    frame; // ~64ms -> Deve acordar
    
 
}

frame(10);
timeTest();
frame(10);

 struct State { x, y };

def worker(st)
{
    var steps = 0;
    while (steps < 3) 
    {  
        st.x = st.x + 1;
        print("Step " + steps + ": x=" + st.x);
        yield;
        steps++;
    }
    print("Worker Done");
}

process enemy()
{
    var s = State(0, 0);
    fiber worker(s);
    
    // Deixamos o fiber correr 4 frames
    frame; frame; frame; frame;
    
    print("State updated by fiber");
}

enemy();


 var s = State(0, 0);
 fiber worker(s);
 fiber worker(s);
 fiber worker(s);

// Deixamos o fiber correr 4 frames
frame; frame; frame; frame;

print("State updated by main fiber");